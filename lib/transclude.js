// Generated by CoffeeScript 1.8.0
(function() {
  var FILE_GROUP, WHITESPACE_GROUP, async, circularReferences, fs, merge, parse, path, readFile, scan, transclude,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  fs = require('fs');

  path = require('path');

  merge = require('lodash.merge');

  WHITESPACE_GROUP = 1;

  FILE_GROUP = 2;

  parse = function(parameters, dir, verbose) {
    var filename, p, parsed, placeholder, _i, _len, _ref, _ref1;
    if (!parameters) {
      cb(null, null);
    }
    parsed = {};
    _ref = (function() {
      var _j, _len, _results;
      _results = [];
      for (_j = 0, _len = parameters.length; _j < _len; _j++) {
        p = parameters[_j];
        _results.push(p.split(":"));
      }
      return _results;
    })();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], placeholder = _ref1[0], filename = _ref1[1];
      if (!filename) {
        console.error("Malformed reference " + placeholder + ". Expected placeholder:filename");
      } else {
        parsed[placeholder] = path.join(dir, filename);
      }
    }
    return parsed;
  };

  scan = function(document, dir, verbose, cb) {
    var detect, filename, parameters, placeholder, placeholders, reference, references, whitespace;
    references = {};
    detect = new RegExp(/([^|\n]{1}[\t ]*)?{{(.+?)}}/g);
    placeholders = (function() {
      var _ref, _results;
      _results = [];
      while ((reference = detect.exec(document))) {
        placeholder = reference[FILE_GROUP];
        whitespace = reference[WHITESPACE_GROUP];
        _ref = placeholder.split(" "), filename = _ref[0], parameters = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
        references[placeholder] = {
          filepath: path.join(dir, filename),
          whitespace: whitespace,
          parameters: parse(parameters, dir, verbose)
        };
        _results.push(placeholder);
      }
      return _results;
    })();
    return cb(null, placeholders, references);
  };

  circularReferences = function(file, parents, parameters, cb) {
    var placeholder, reference;
    if (parents == null) {
      parents = [];
    }
    if (parameters == null) {
      parameters = {};
    }
    if (__indexOf.call(parents, file) >= 0) {
      return cb("Error 1: Circular reference detected. " + file + " is in parents:\n" + (JSON.stringify(parents)));
    }
    for (placeholder in parameters) {
      reference = parameters[placeholder];
      if (reference === file) {
        return cb("Error 2: Circular parameter reference detected. " + file + " is included as a reference: " + placeholder + ":" + reference);
      }
    }
    return cb(null);
  };

  readFile = function(filename, cb) {
    return fs.readFile(filename, function(err, document) {
      if (err) {
        if (err.type = 'ENOENT') {
          console.error("" + filename + " not found.");
          return cb(null, '');
        }
        return cb(err);
      }
      return cb(null, document.toString());
    });
  };

  transclude = function(file, parents, parameters, verbose, cb) {
    var relativePath;
    if (parents == null) {
      parents = [];
    }
    if (parameters == null) {
      parameters = {};
    }
    if (verbose) {
      console.error("Transcluding " + file + "\n\tparents: " + (JSON.stringify(parents)) + "\n\tparameters: " + (JSON.stringify(parameters)));
    }
    relativePath = path.dirname(file);
    circularReferences(file, parents, parameters, function(err) {
      if (err) {
        return cb(err);
      }
    });
    parents.push(file);
    return readFile(file, function(err, document) {
      if (err) {
        return cb(err);
      }
      return scan(document, relativePath, verbose, function(err, placeholders, dependencies) {
        if (err) {
          return cb(err);
        }
        if (placeholders === []) {
          return cb(null, document);
        }
        return async.eachSeries(placeholders, function(placeholder, cb) {
          var dependency, dependencyFilepath, dependencyParameters;
          dependency = dependencies[placeholder];
          dependencyFilepath = parameters[placeholder] != null ? parameters[placeholder] : dependency.filepath;
          dependencyParameters = merge(parameters, dependency.parameters);
          return transclude(dependencyFilepath, parents.slice(0), dependencyParameters, verbose, function(err, output) {
            var insertionPoint;
            if (err) {
              return cb(err);
            }
            if (dependency.whitespace) {
              output = output.replace(/\n/g, "\n" + dependency.whitespace);
            }
            insertionPoint = new RegExp("{{" + placeholder + "}}", "g");
            document = document.replace(insertionPoint, output);
            return cb(null);
          });
        }, function(err) {
          return cb(null, document);
        });
      });
    });
  };

  module.exports = {
    transclude: transclude,
    scan: scan,
    parse: parse,
    circularReferences: circularReferences
  };

}).call(this);
