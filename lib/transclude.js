// Generated by CoffeeScript 1.8.0
(function() {
  var FILE_GROUP, WHITESPACE_GROUP, async, detectDependencies, fs, merge, parseParameters, path, tap, transclude,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  fs = require('fs');

  path = require('path');

  WHITESPACE_GROUP = 1;

  FILE_GROUP = 2;

  parseParameters = function(parameters, relativePath, verbose) {
    var filename, p, parsedParameters, placeholder, _i, _len, _ref, _ref1;
    if (!parameters) {
      cb(null, null);
    }
    parsedParameters = {};
    _ref = (function() {
      var _j, _len, _results;
      _results = [];
      for (_j = 0, _len = parameters.length; _j < _len; _j++) {
        p = parameters[_j];
        _results.push(p.split(":"));
      }
      return _results;
    })();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], placeholder = _ref1[0], filename = _ref1[1];
      if (!filename) {
        console.error("Malformed parameter " + placeholder + ". Expected placeholder:filename");
      } else {
        parsedParameters[placeholder] = path.join(relativePath, filename);
      }
    }
    return parsedParameters;
  };

  detectDependencies = function(document, relativePath, verbose, cb) {
    var dependencies, dependency, detect, filename, parameters, placeholder, placeholders, whitespace;
    dependencies = {};
    detect = new RegExp(/([^|\n]{1}[\t ]*)?{{(.+?)}}/g);
    placeholders = (function() {
      var _ref, _results;
      _results = [];
      while ((dependency = detect.exec(document))) {
        placeholder = dependency[FILE_GROUP];
        whitespace = dependency[WHITESPACE_GROUP];
        _ref = placeholder.split(" "), filename = _ref[0], parameters = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
        dependencies[placeholder] = {
          path: path.join(relativePath, filename),
          whitespace: whitespace,
          parameters: parseParameters(parameters, relativePath, verbose)
        };
        _results.push(placeholder);
      }
      return _results;
    })();
    return cb(null, placeholders, dependencies);
  };

  merge = function() {
    var xs;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if ((xs != null ? xs.length : void 0) > 0) {
      return tap({}, function(m) {
        var k, v, x, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (k in x) {
              v = x[k];
              _results1.push(m[k] = v);
            }
            return _results1;
          })());
        }
        return _results;
      });
    }
  };

  tap = function(o, fn) {
    fn(o);
    return o;
  };

  transclude = function(file, parents, parameters, verbose, cb) {
    var relativePath;
    if (parents == null) {
      parents = [];
    }
    if (verbose) {
      console.error("Transcluding " + file);
    }
    relativePath = path.dirname(file);
    if (__indexOf.call(parents, file) >= 0) {
      cb("circular dependencies detected");
    }
    parents.push(file);
    return fs.readFile(file, function(err, document) {
      if (err) {
        if (err.type = 'ENOENT') {
          console.error("" + file + " not found.");
          return cb(null, '');
        }
        return cb(err);
      }
      document = document.toString();
      return detectDependencies(document, relativePath, verbose, function(err, placeholders, dependencies) {
        if (err) {
          return cb(err);
        }
        if (placeholders === []) {
          return cb(null, document);
        }
        return async.eachSeries(placeholders, function(placeholder, cb) {
          var dependency;
          dependency = dependencies[placeholder];
          if ((parameters != null ? parameters[placeholder] : void 0) != null) {
            dependency.path = parameters[placeholder];
          }
          if (parameters === !null) {
            dependency.parameters = merge(parameters.slice(0), dependency.parameters.slice(0));
          }
          return transclude(dependency.path, parents.slice(0), dependency.parameters, verbose, function(err, output) {
            var insertionPoint;
            if (err) {
              return cb(err);
            }
            if (dependency.whitespace) {
              output = output.replace(/\n/g, "\n" + dependency.whitespace);
            }
            insertionPoint = new RegExp("{{" + placeholder + "}}", "g");
            document = document.replace(insertionPoint, output);
            return cb(null);
          });
        }, function(err) {
          return cb(null, document);
        });
      });
    });
  };

  module.exports = {
    transclude: transclude,
    detectDependencies: detectDependencies,
    parseParameters: parseParameters
  };

}).call(this);
